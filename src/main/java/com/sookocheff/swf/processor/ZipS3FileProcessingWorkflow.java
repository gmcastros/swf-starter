package com.sookocheff.swf.processor;

import java.io.IOException;

import com.amazonaws.services.simpleworkflow.flow.ActivitySchedulingOptions;
import com.amazonaws.services.simpleworkflow.flow.DecisionContextProviderImpl;
import com.amazonaws.services.simpleworkflow.flow.annotations.Asynchronous;
import com.amazonaws.services.simpleworkflow.flow.core.Promise;
import com.amazonaws.services.simpleworkflow.flow.core.Settable;
import com.amazonaws.services.simpleworkflow.flow.core.TryCatchFinally;

/**
 * Implements the workflow for downloading a file from S3, zipping it,
 * and uploading the result back to S3.
 */
public class ZipS3FileProcessingWorkflow implements FileProcessingWorkflow {

  // Storage client is auto-generated by flow framework to process storage activities
  private final StorageActivitiesClient storageClient;

  // File client is auto-generated by flow framework to process file activities
  private final FileActivitiesClient fileClient;

  private final String runId;

  private String state = "Started";

  /**
   * Create a new instance of this workflow.
   */
  public ZipS3FileProcessingWorkflow() {
    storageClient = new StorageActivitiesClientImpl();
    fileClient = new FileActivitiesClientImpl();
    runId = (new DecisionContextProviderImpl())
        .getDecisionContext()
        .getWorkflowContext()
        .getWorkflowExecution()
        .getRunId();
  }

  /**
   * Process the file at inputBucketName.inputFileName.
   * Place the result at outputBucketName.outputFileName.
   *
   * @param inputBucketName input bucket to process from
   * @param inputFileName input file to process from
   * @param outputBucketName output bucket to put result to
   * @param outputFileName output file to put result to
   * @throws IOException
   */
  @Override
  public void processFile(String inputBucketName, String inputFileName, String outputBucketName, String outputFileName)
      throws IOException {
    // Settable is a Promise implementation that exposes a "chain" method that allows you to
    // link the state of one Promise to that of another
    Settable<String> hostNameChain = new Settable<String>();

    // Use prepend runId to input and output name way to avoid name collisions
    String localInputFileName = runId + "_" + inputFileName;
    String localOutputFileName = runId + "_" + outputFileName;

    // TryCatchFinally provides an asynchronous version of a typical synchronous try-catch-finally block
    // For example, if any task that is started in the doTry block throws an exception,
    // all tasks within the doTry block are cancelled and flow moves to the doCatch block.
    new TryCatchFinally() {

      /**
       * Download the file from S3, process it locally through a chained task, and upload back to S3.
       * @throws Throwable
       */
      @Override
      protected void doTry() throws Throwable {
        // download from S3, returns the host that downloaded the file
        Promise<String> hostName = storageClient.download(inputBucketName, inputFileName, localInputFileName);

        // chaining is a way for one promise to get assigned the value of another
        // when the promise is complete, it's value will be available for subsequent operations
        hostNameChain.chain(hostName);

        // zip the file on the local host
        processFileOnHost(localInputFileName, localOutputFileName, hostName);

        // upload the zipped file back to S3
        upload(outputBucketName, outputFileName, localOutputFileName, hostNameChain);
      }

      @Override
      protected void doCatch(Throwable e) throws Throwable {
        state = "Failed: " + e.getMessage();
        throw e;
      }

      @Override
      protected void doFinally() throws Throwable {
        if (hostNameChain.isReady()) { // File was downloaded

          // Set option to schedule activity in worker specific task list
          ActivitySchedulingOptions options = new ActivitySchedulingOptions().withTaskList(hostNameChain.get());

          // Call deleteLocalFile activity using the host specific task list
          storageClient.deleteLocalFile(localInputFileName, options);
          storageClient.deleteLocalFile(localOutputFileName, options);
        }
        if (!state.startsWith("Failed:")) {
          state = "Completed";
        }
      }

    };
  }

  /**
   * Processes the file downloaded to the local host.
   *
   * @param localInputFileName name of the file to process
   * @param localOutputFileName name of the file to upload to S3
   * @param hostName host processing the file
   */
  @Asynchronous
  private Promise<Void> processFileOnHost(String localInputFileName, String localOutputFileName, Promise<String> hostName) {
    state = "Downloaded to " + hostName.get();

    // Process the file using the local hosts SWF task list
    ActivitySchedulingOptions options = new ActivitySchedulingOptions().withTaskList(hostName.get());
    return fileClient.processFile(localInputFileName, localOutputFileName, options);
  }

  /**
   * Upload the file to S3.
   *
   * @param outputBucketName S3 bucket to upload to
   * @param outputFilename S3 file to upload to
   * @param localFileName local file to upload
   * @param hostName host processing the file
   */
  @Asynchronous
  private void upload(String outputBucketName, String outputFilename, String localFileName, Promise<String> hostName) {
    state = "Processed at " + hostName.get();

    // Upload the file using the local hosts SWF task list
    ActivitySchedulingOptions options = new ActivitySchedulingOptions().withTaskList(hostName.get());
    storageClient.upload(outputBucketName, localFileName, outputFilename, options);
  }

  /**
   * Get the current state of the workflow. This is reported to the SWF console and
   * through SWF APIs.
   *
   * When the decider is done processing a decision task, it fetches the latest state
   * using the @GetState annotation.
   *
   * @return current state of the workflow
   */
  @Override
  public String getState() {
    return state;
  }

}